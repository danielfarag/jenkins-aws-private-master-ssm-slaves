# Automated Jenkins Environment with SSM / Nginx Reverse Proxy (In-progress)

This project automates the deployment of a Jenkins environment on AWS EC2 instances, complete with an Nginx reverse proxy to expose Jenkins on standard HTTP/HTTPS ports. Terraform is used for infrastructure provisioning, and Ansible handles the configuration and software installation.

**A core security principle of this setup is that all SSH ports are closed.** This means you cannot directly SSH into the Jenkins master or slave instance. Instead, all remote management and interaction with these instances **rely exclusively on AWS Systems Manager (SSM)**.

Furthermore, **Agents cannot directly reach the Jenkins master** due to stringent security group constraints. All Jenkins agent communication is expected to leverage other protocols configured by the Ansible playbooks, ensuring a more secure, locked-down environment.

---

## Project Structure

The project is organized into the following directories:

```
├── ansible
│   ├── ansible.cfg
│   ├── inventory             # Dynamic inventory generated by Terraform
│   ├── inventory.sample      # Example inventory file
│   ├── jenkins.yaml          # Ansible playbook for Jenkins installation
│   ├── nginx.yaml            # Ansible playbook for Nginx configuration
│   ├── password              # Stores the initial Jenkins admin password after deployment
│   └── slave.yaml            # Ansible playbook for Jenkins slave configuration
├── Makefile                  # Simplifies common project operations
├── README.md                 # Project documentation
└── terraform
    ├── backend.tf            # Configures Terraform backend (e.g., S3 for state management)
    ├── main.tf               # Main Terraform configuration for module orchestration
    ├── modules
    │   ├── compute           # Defines EC2 instances, security groups, and IAM roles
    │   │   ├── data.tf
    │   │   ├── ec2.tf
    │   │   ├── keys.tf
    │   │   ├── outputs.tf
    │   │   ├── roles.tf
    │   │   ├── secuity_groups.tf
    │   │   ├── ssm-agent.sh  # Script to install AWS SSM Agent
    │   │   └── variables.tf
    │   ├── network           # Defines VPC, subnets, routing, and gateways
    │   │   ├── igw.tf
    │   │   ├── nat.tf
    │   │   ├── outputs.tf
    │   │   ├── routing-tables.tf
    │   │   ├── subnets.tf
    │   │   ├── variables.tf
    │   │   └── vpc.tf
    │   └── storage           # Defines S3 buckets (if used)
    │       └── bucket.tf
    ├── outputs.tf            # Defines output variables from Terraform (e.g., IPs, instance IDs)
    ├── providers.tf          # Configures AWS provider
    ├── variables.tf          # Defines input variables for Terraform
    └── vars.tfvars           # Example variable values
```

---

## Architecture

The project deploys the following AWS resources:

* **VPC and Networking:** A dedicated Virtual Private Cloud (VPC) with public and private subnets, an Internet Gateway (IGW), and a NAT Gateway for outbound internet access from private subnets.
* **EC2 Instances:**
    * **Nginx Server:** A public EC2 instance acting as a reverse proxy for Jenkins. It's configured to listen on ports 80 (HTTP) and 443 (HTTPS - although SSL isn't configured in the provided Nginx playbook, the security group allows it).
    * **Jenkins Master:** A private EC2 instance running the Jenkins CI/CD server. It's accessible via the Nginx reverse proxy.
    * **Jenkins Slave:** A private EC2 instance intended to function as a Jenkins build agent.
* **Security Groups:**
    * `aws_security_group.nginx`: Allows inbound HTTP (80) and HTTPS (443) traffic from anywhere to the Nginx server.
    * `aws_security_group.jenkins`: Allows inbound traffic on port 8080 (Jenkins UI) and 50000 (Jenkins agent communication) only from the Nginx server's security group. It also allows inbound HTTPS (443) from anywhere.
    * `aws_security_group.slave`: Allows outbound internet access and inbound HTTPS (443) from anywhere (note: for a production setup, inbound rules from the Jenkins master for agent communication would be more restrictive).
* **IAM Instance Profiles:** EC2 instances are configured with an IAM instance profile (`ssm_ec2_profile`) to allow AWS Systems Manager (SSM) Agent to run, enabling remote management without SSH keys.

---

## Getting Started

### Prerequisites

* **AWS Account:** You need an active AWS account.
* **AWS CLI Configured:** Ensure your AWS CLI is configured with appropriate credentials and a default region.
* **Terraform:** Install Terraform ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)).
* **Ansible:** Install Ansible ([https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)).
* **`make`:** Ensure `make` is installed on your system.

### Deployment Steps

1.  **Clone the Repository:**
    ```bash
    git clone https://github.com/danielfarag/jenkins-aws-private-master-ssm-slaves.git
    cd jenkins-aws-private-master-ssm-slaves
    ```

2.  **Configure Terraform Variables:**
    Review and modify `terraform/vars.tfvars` to suit your needs. This file defines variables such as `ami_type`, `availability_zone`, etc.

3.  **Provision Infrastructure:**
    Use `make terraform` to initialize Terraform and provision the AWS infrastructure. This will create the VPC, subnets, EC2 instances, security groups, and other necessary resources.
    ```bash
    make terraform
    ```

4.  **Generate Ansible Inventory:**
    After Terraform completes, generate the dynamic Ansible inventory using the `make inventory` command. This will populate `ansible/inventory` with the details of your deployed instances.
    ```bash
    make inventory
    ```
    **Caution:** If you encounter errors immediately after running `make inventory` when proceeding to the `make ansible` step, it might be due to the AWS SSM Agent not being fully initialized on the EC2 instances yet. Please wait 1-2 minutes and try running `make ansible` again.

5.  **Run Ansible Playbooks:**
    Execute the Ansible playbooks to install and configure Jenkins, Nginx, and the Jenkins slave. This process can take several minutes.
    ```bash
    make ansible
    ```

6.  **Access Jenkins and Connection Details:**
    Once all the `make` commands complete, use `make auth` to retrieve the Jenkins URL, initial admin password, and slave connection details.
    ```bash
    make auth
    ```
    You will see output similar to:
    ```
    jenkins_server    = <YOUR_NGINX_PUBLIC_IP>
    jenkins_password  = <YOUR_JENKINS_INITIAL_ADMIN_PASSWORD>
    slave_id          = <YOUR_SLAVE_INSTANCE_ID>
    connect to slave using = aws ssm start-session --target <slave-id> --region <region>
    ```
    Navigate to `http://<YOUR_NGINX_PUBLIC_IP>` in your web browser and use the provided password to unlock Jenkins and complete the initial setup.

    > ⚠️ **Important:** Ensure that port `50000` is open on the Jenkins controller (gui master `security.agents`) in order to use **JNLP (Java Web Start) agents**. This port is used for communication between Jenkins agents and the controller, and blocking it can prevent agents from connecting successfully.
---

## Makefile Commands

The `Makefile` provides convenient commands for managing the environment:

* `make terraform`: Initializes Terraform and runs `terraform apply` to provision or update AWS resources.
* `make inventory`: Generates the dynamic Ansible inventory file (`ansible/inventory`) based on Terraform outputs.
* `make ansible`: Executes the Ansible playbooks (`jenkins.yaml`, `nginx.yaml`, `slave.yaml`).
* `make auth`: Displays the Jenkins public URL, initial admin password, and the Jenkins slave instance ID with instructions on how to connect via SSM.
* `make clean`: Destroys all AWS resources provisioned by Terraform.

---

## Customization

* **Instance Types:** Modify the `ami_type` variable in `terraform/variables.tf` or `terraform/vars.tfvars` to change the EC2 instance types.
* **Regions/Availability Zones:** Adjust the `aws_region` and `availability_zone` variables in `terraform/variables.tf` or `terraform/vars.tfvars`.
* **Security Group Rules:** Customize the ingress and egress rules within the `aws_security_group` resources in `terraform/modules/compute/secuity_groups.tf` to restrict network access as needed.
* **Jenkins Version/Plugins:** Modify the `jenkins.yaml` Ansible playbook to install a different Jenkins version or specific plugins.
* **Nginx Configuration:** Adjust the `nginx.yaml` playbook to change Nginx's reverse proxy settings or add SSL/TLS configuration.

---

## Cleanup

To destroy all the AWS resources created by this project, simply run:

```bash
make clean
```
This command will execute `terraform destroy --auto-approve` to de-provision all resources.

---
